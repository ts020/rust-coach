# Rustコーチングプラン

## コンセプト
- プロジェクト指向Rust学習
- 最終目標: JSONからHTMLを高速に生成するジェネレータの開発

## 学習者情報
- 詳細は [学習者プロファイル](learner_profile.md) を参照

## コーチングプロセス
1. 各セッションの開始時に前回の内容を簡単に復習
2. 新しい概念や技術の紹介と説明
3. 実践的な演習を通じた学習
4. 質問への回答と疑問点の解消
5. 次回の学習内容の予告
6. **学習者プロファイルの随時更新**：セッション中に気づいた特性や傾向を記録（RooCodeの責務）
7. コーチングプランの調整（必要に応じて）

## コーチング方針
1. **説明と例示の分離**：
   - コードを直接変更するのではなく、「以下は〇〇の例です」と明示して例を示す
   - 例示コードは、ユーザーのコードとは別のものとして提示する

2. **段階的なガイダンス**：
   - 「次のステップとして、〇〇を試してみてはいかがでしょうか？」という形で提案する
   - 一度に全ての変更を提案するのではなく、小さなステップに分ける

3. **質問形式の活用**：
   - 「〇〇についてどう思いますか？」「〇〇を追加するとどうなると思いますか？」など、ユーザーに考えるきっかけを与える質問をする

4. **フィードバックの提供**：
   - ユーザーが実装したコードに対して、具体的なフィードバックを提供する
   - 良い点を強調し、改善点を提案する

5. **コードの直接改変を避ける**：
   - ユーザーのコードを直接改変せず、コーチングに徹する
   - 変更が必要な場合は、変更案を提示し、ユーザーが自分で実装できるようにガイドする

## 学習ロードマップ
1. 基礎フェーズ: Rustの基本構文と概念（モジュール1-3）
2. 応用フェーズ: データ構造とエラー処理（モジュール4-5）
3. 統合フェーズ: JSONパースとHTML生成の基本実装
4. 拡張フェーズ: WebAssemblyとFFIによる連携

## 現在の進捗

### コーチング準備
- [x] コーチングコンセプトの決定
- [x] 学習者プロファイルの作成
- [x] コーチングプロセスの確立

### モジュール1: Rustの紹介と環境構築
- [x] 1.1 Rustとは
- [x] 1.2 Rustが解決する問題
- [x] 1.3 Rustの使用例
- [x] 1.4 環境構築
- [x] 1.5 最初のRustプログラム
- [x] 1.6 Cargoの基本

### モジュール2: 基本的な構文と概念
- [x] 2.1 変数と可変性
  - [x] 基本的な変数宣言
  - [x] 可変性（mutキーワード）
  - [x] シャドーイングの概念
- [x] 2.2 データ型
  - [x] スカラー型（整数、浮動小数点、論理値、文字）
  - [x] 複合型（タプル、配列）
  - [x] 文字列型（String, &str）
  - [x] Option<T>型とパターンマッチング
- [x] 2.3 関数
  - [x] 関数の定義と呼び出し
  - [x] 引数と戻り値
  - [x] 式と文
  - [x] 関数とOption<T>型の組み合わせ
- [x] 2.4 制御フロー
  - [x] if式
  - [x] ループ（loop, while, for）
  - [x] match式
- [x] 2.5 コメント
- [x] 2.6 基本的な入出力

### モジュール3: 所有権システム
- [ ] 3.1 所有権の概念
- [ ] 3.2 参照と借用
- [ ] 3.3 スライス

### 最新の学習状況
- モジュール2.5のコメントとモジュール2.6の基本的な入出力を学習完了
- 標準入力からの入力方法（io::stdin().read_line()）を学習
- ファイル入出力（fs::File::create, writeln!, fs::read_to_string）を学習
- 素数リストをファイルに保存するプログラムを実装

## 次回の学習内容
- モジュール3.1の所有権の概念

## プロジェクト計画: JSON-HTMLジェネレータ
1. 基本実装: JSONパースと単純なHTML生成
2. 拡張機能: テンプレート機能とスタイル適用
3. パフォーマンス最適化: 高速化とメモリ効率
4. 連携機能: WebAssemblyとFFI実装

## セッション記録

### セッション1 (2025/3/1)
- コーチングコンセプトの決定
- 学習者の背景と目標の確認
- 次回: モジュール2の基本構文と概念の学習開始

### セッション2 (2025/3/1)
- モジュール2.2のデータ型（複合型と文字列型）の学習
- Option<T>型とパターンマッチングの概念紹介
- コーチング方針の確立とroocode_config.jsonの作成
- 次回: Option<T>型とパターンマッチングの実践演習

### セッション3 (2025/3/1)
- Option<T>型とパターンマッチングの実践演習
- matchとif let構文の使い方
- 所有権とCopyトレイトの関係（i32とStringの違い）
- パフォーマンスの観点からの参照渡しと値渡しの比較
- コーチング方針の改善（一つの課題に集中し、段階的に進める）
- 次回: モジュール2.3の関数と関数を使ったOption<T>型の処理

### セッション4 (2025/3/1)
- Rustの関数の基本（定義と呼び出し）
- 戻り値を明示的に返す方法（returnキーワード）
- 条件分岐を含む関数の実装
- 複数の引数と異なる型の引数を持つ関数
- 関数とOption<T>型を組み合わせた安全なコードの書き方
- 文字列型（&strとString）の違いと参照渡しの理解
- 次回: モジュール2.4の制御フロー

### セッション5 (2025/3/1)
- Rustの制御フロー構文（if式、match式、ループ）の学習
- for, while, loopの各ループ構文の使い方と違い
- 制御フロー構文を組み合わせた素数判定プログラムの実装
- 効率的なアルゴリズム（√nまでのチェック）の理解
- 次回: モジュール2.5のコメントとモジュール2.6の基本的な入出力

### セッション6 (2025/3/1)
- Rustのコメント（行コメント、ブロックコメント、ドキュメンテーションコメント）の概要
- 標準入力からの入力方法（io::stdin().read_line()）の学習
- 入力された文字列を数値に変換する方法（trim().parse()）
- ファイル入出力の基本（fs::File::create, writeln!, fs::read_to_string）
- 素数リストをファイルに保存するプログラムの実装
- 次回: モジュール3.1の所有権の概念